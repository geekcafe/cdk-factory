"""
Lambda@Edge function for IP-based access gating.
Geek Cafe, LLC
Maintainers: Eric Wilson

Since Lambda@Edge does not support environment variables, configuration
is fetched from SSM Parameter Store at runtime (with caching).
"""
import json
import ipaddress
import boto3
from functools import lru_cache

# SSM client - will be created in the region where the function executes
ssm = None

@lru_cache(maxsize=128)
def get_ssm_parameter(parameter_name: str, region: str = 'us-east-1') -> str:
    """
    Fetch SSM parameter with caching.
    Lambda@Edge cannot use environment variables, so we fetch from SSM.
    
    The sentinel value 'NONE' indicates an explicitly unset/disabled parameter.
    
    Args:
        parameter_name: Name of the SSM parameter
        region: AWS region (default us-east-1)
    
    Returns:
        Parameter value, or empty string if value is 'NONE'
    """
    global ssm
    if ssm is None:
        ssm = boto3.client('ssm', region_name=region)
    
    try:
        response = ssm.get_parameter(Name=parameter_name, WithDecryption=False)
        value = response['Parameter']['Value']
        
        # Treat 'NONE' sentinel as empty/unset
        if value == 'NONE':
            print(f"SSM parameter {parameter_name} is set to 'NONE' (explicitly disabled)")
            return ''
        
        return value
    except Exception as e:
        print(f"Error fetching SSM parameter {parameter_name}: {str(e)}")
        raise


def get_client_ip(request):
    """Extract client IP from CloudFront request."""
    if 'clientIp' in request:
        return request['clientIp']
    
    # Fallback to headers
    headers = request.get('headers', {})
    if 'x-forwarded-for' in headers:
        xff = headers['x-forwarded-for'][0]['value']
        return xff.split(',')[0].strip()
    
    return None


def is_ip_allowed(client_ip: str, allowed_cidrs: list) -> bool:
    """
    Check if client IP is in any of the allowed CIDR ranges.
    
    Args:
        client_ip: Client IP address
        allowed_cidrs: List of CIDR ranges (e.g., ['10.0.0.0/8', '192.168.1.0/24'])
    
    Returns:
        True if IP is allowed, False otherwise
    """
    if not client_ip:
        return False
    
    try:
        client_ip_obj = ipaddress.ip_address(client_ip)
    except ValueError as e:
        print(f"Invalid client IP address: {e}")
        return False
    
    # Check each CIDR individually, skipping invalid ones
    for cidr in allowed_cidrs:
        try:
            network = ipaddress.ip_network(cidr.strip(), strict=False)
            if client_ip_obj in network:
                return True
        except ValueError as e:
            # Invalid CIDR, log and continue checking others
            print(f"Invalid CIDR '{cidr}': {e}")
            continue
    
    return False


def lambda_handler(event, context):
    """
    Lambda@Edge function for IP-based gating.
    
    Configuration (fetched from SSM Parameter Store):
    - GATE_ENABLED: Whether IP gating is enabled (true/false)
    - ALLOW_CIDRS: Comma-separated list of allowed CIDR ranges
    - MAINT_CF_HOST: CloudFront domain for maintenance/lockout page
    
    Runtime configuration is bundled in runtime_config.json by CDK.
    SSM parameter paths are auto-generated by CDK as:
    /{environment}/{full-function-name}/{env-var-name-kebab-case}
    """
    request = event['Records'][0]['cf']['request']
    
    # Load runtime configuration bundled by CDK
    # This file is created during deployment and contains environment, function name, etc.
    try:
        with open('runtime_config.json', 'r') as f:
            runtime_config = json.load(f)
        
        env = runtime_config.get('environment', 'dev')
        function_base_name = runtime_config.get('function_name', 'ip-gate')
        
        print(f"Runtime config loaded: environment={env}, function_name={function_base_name}")
    except FileNotFoundError:
        # Fallback: extract from Lambda context (less reliable)
        print("Warning: runtime_config.json not found, falling back to function name parsing")
        function_full_name = context.function_name
        
        # Parse environment from function name as fallback
        parts = function_full_name.split('-')
        common_envs = ['dev', 'prod', 'staging', 'test', 'qa', 'uat']
        env = 'dev'
        
        for part in parts:
            if part in common_envs:
                env = part
                break
        
        function_base_name = 'ip-gate'
        print(f"Fallback: environment={env}, function_name={function_base_name}")
    
    # Full function name for SSM paths
    # Lambda@Edge replicas prepend region (e.g., "us-east-1.tech-talk-dev-ip-gate")
    # Strip the region prefix to get the original function name
    function_name = context.function_name
    if '.' in function_name and function_name.split('.')[0].startswith('us-'):
        # Strip region prefix (e.g., "us-east-1." -> "tech-talk-dev-ip-gate")
        function_name = '.'.join(function_name.split('.')[1:])
        print(f"Stripped region prefix from function name: {function_name}")
    
    print(f"Lambda function ARN: {context.invoked_function_arn}")
    print(f"Using function name for SSM lookups: {function_name}")
    
    try:
        # Fetch configuration from SSM Parameter Store
        # Auto-generated paths: /{env}/{function-name}/{key}
        gate_enabled = get_ssm_parameter(f'/{env}/{function_name}/gate-enabled', 'us-east-1')
        
        # If gating is disabled, allow all traffic
        # Empty string (from 'NONE' sentinel) is treated as disabled
        if not gate_enabled or gate_enabled.lower() not in ('true', '1', 'yes'):
            print(f"IP gating is disabled (GATE_ENABLED={gate_enabled or 'NONE'})")
            return request
        
        # Get allowed CIDRs and maintenance host
        allow_cidrs_str = get_ssm_parameter(f'/{env}/{function_name}/allow-cidrs', 'us-east-1')
        maint_cf_host = get_ssm_parameter(f'/{env}/{function_name}/maint-cf-host', 'us-east-1')
        
        # Parse allowed CIDRs (empty string results in empty list)
        allowed_cidrs = [cidr.strip() for cidr in allow_cidrs_str.split(',') if cidr.strip()]
        
        # Get client IP
        client_ip = get_client_ip(request)
        print(f"Client IP: {client_ip}")
        
        # Check if IP is allowed
        if is_ip_allowed(client_ip, allowed_cidrs):
            print(f"IP {client_ip} is allowed")
            return request
        
        # IP not allowed - redirect to maintenance page
        print(f"IP {client_ip} is NOT allowed, redirecting to {maint_cf_host}")
        
        response = {
            'status': '302',
            'statusDescription': 'Found',
            'headers': {
                'location': [{
                    'key': 'Location',
                    'value': f'https://{maint_cf_host}'
                }],
                'cache-control': [{
                    'key': 'Cache-Control',
                    'value': 'no-cache, no-store, must-revalidate'
                }]
            }
        }
        
        return response
        
    except Exception as e:
        print(f"Error in IP gating function: {str(e)}")
        # On error, allow the request to proceed (fail open)
        # Change this to fail closed if preferred
        return request
