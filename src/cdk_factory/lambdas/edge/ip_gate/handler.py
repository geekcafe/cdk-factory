"""
Lambda@Edge function for IP-based access gating.
Geek Cafe, LLC
Maintainers: Eric Wilson

Since Lambda@Edge does not support environment variables, configuration
is fetched from SSM Parameter Store at runtime (with caching).
"""
import json
import ipaddress
import boto3
from functools import lru_cache

# SSM client - will be created in the region where the function executes
ssm = None

@lru_cache(maxsize=128)
def get_ssm_parameter(parameter_name: str, region: str = 'us-east-1', default: str = None) -> str:
    """
    Fetch SSM parameter with caching.
    Lambda@Edge cannot use environment variables, so we fetch from SSM.
    
    The sentinel value 'NONE' indicates an explicitly unset/disabled parameter.
    
    Args:
        parameter_name: Name of the SSM parameter
        region: AWS region (default us-east-1)
        default: Default value to return if parameter not found (optional)
    
    Returns:
        Parameter value, default value if parameter not found, or empty string if value is 'NONE'
    """
    global ssm
    if ssm is None:
        ssm = boto3.client('ssm', region_name=region)
    
    try:
        response = ssm.get_parameter(Name=parameter_name, WithDecryption=False)
        value = response['Parameter']['Value']
        
        # Treat 'NONE' sentinel as empty/unset
        if value == 'NONE':
            print(f"SSM parameter {parameter_name} is set to 'NONE' (explicitly disabled)")
            return ''
        
        return value
    except ssm.exceptions.ParameterNotFound:
        if default is not None:
            print(f"SSM parameter {parameter_name} not found, using default: {default}")
            return default
        print(f"SSM parameter {parameter_name} not found and no default provided")
        raise
    except Exception as e:
        print(f"Error fetching SSM parameter {parameter_name}: {str(e)}")
        if default is not None:
            print(f"Returning default value due to error: {default}")
            return default
        raise


def get_client_ip(request):
    """Extract client IP from CloudFront request."""
    if 'clientIp' in request:
        return request['clientIp']
    
    # Fallback to headers
    headers = request.get('headers', {})
    if 'x-forwarded-for' in headers:
        xff = headers['x-forwarded-for'][0]['value']
        return xff.split(',')[0].strip()
    
    return None


def is_ip_allowed(client_ip: str, allowed_cidrs: list) -> bool:
    """
    Check if client IP is in any of the allowed CIDR ranges.
    
    Args:
        client_ip: Client IP address
        allowed_cidrs: List of CIDR ranges (e.g., ['10.0.0.0/8', '192.168.1.0/24'])
    
    Returns:
        True if IP is allowed, False otherwise
    """
    if not client_ip:
        return False
    
    try:
        client_ip_obj = ipaddress.ip_address(client_ip)
    except ValueError as e:
        print(f"Invalid client IP address: {e}")
        return False
    
    # Check each CIDR individually, skipping invalid ones
    for cidr in allowed_cidrs:
        try:
            network = ipaddress.ip_network(cidr.strip(), strict=False)
            if client_ip_obj in network:
                return True
        except ValueError as e:
            # Invalid CIDR, log and continue checking others
            print(f"Invalid CIDR '{cidr}': {e}")
            continue
    
    return False


def lambda_handler(event, context):
    """
    Lambda@Edge function for IP-based gating.
    
    Configuration (fetched from SSM Parameter Store):
    - GATE_ENABLED: Whether IP gating is enabled (true/false)
    - ALLOW_CIDRS: Comma-separated list of allowed CIDR ranges
    - DNS_ALIAS: CloudFront domain for backup/lockout page
    
    Runtime configuration is bundled in runtime_config.json by CDK.
    SSM parameter paths are auto-generated by CDK as:
    /{environment}/{full-function-name}/{env-var-name-kebab-case}
    """
    request = event['Records'][0]['cf']['request']
    
    # Load runtime configuration bundled by CDK
    # This file is created during deployment and contains environment, function name, etc.
    try:
        with open('runtime_config.json', 'r') as f:
            runtime_config = json.load(f)
        
        env = runtime_config.get('environment', 'dev')
        function_base_name = runtime_config.get('function_name', 'ip-gate')
        
        print(f"Runtime config loaded: environment={env}, function_name={function_base_name}")
    except FileNotFoundError:
        # Fallback: extract from Lambda context (less reliable)
        print("Warning: runtime_config.json not found, falling back to function name parsing")
        function_full_name = context.function_name
        
        # Parse environment from function name as fallback
        parts = function_full_name.split('-')
        common_envs = ['dev', 'prod', 'staging', 'test', 'qa', 'uat']
        env = 'dev'
        
        for part in parts:
            if part in common_envs:
                env = part
                break
        
        function_base_name = 'ip-gate'
        print(f"Fallback: environment={env}, function_name={function_base_name}")
    
    # Full function name for SSM paths
    # Lambda@Edge replicas prepend region (e.g., "us-east-1.tech-talk-dev-ip-gate")
    # Strip the region prefix to get the original function name
    function_name = context.function_name
    if '.' in function_name and function_name.split('.')[0].startswith('us-'):
        # Strip region prefix (e.g., "us-east-1." -> "tech-talk-dev-ip-gate")
        function_name = '.'.join(function_name.split('.')[1:])
        print(f"Stripped region prefix from function name: {function_name}")
    
    print(f"Lambda function ARN: {context.invoked_function_arn}")
    print(f"Using function name for SSM lookups: {function_name}")
    
    try:
        # Fetch configuration from SSM Parameter Store
        # Auto-generated paths: /{env}/{function-name}/{key}
        gate_enabled = get_ssm_parameter(f'/{env}/{function_name}/gate-enabled', 'us-east-1')
        
        # If gating is disabled, allow all traffic
        # Empty string (from 'NONE' sentinel) is treated as disabled
        if not gate_enabled or gate_enabled.lower() not in ('true', '1', 'yes'):
            print(f"IP gating is disabled (GATE_ENABLED={gate_enabled or 'NONE'})")
            return request
        
        # Get allowed CIDRs and backup host
        allow_cidrs_str = get_ssm_parameter(f'/{env}/{function_name}/allow-cidrs', 'us-east-1')
        dns_alias = get_ssm_parameter(f'/{env}/{function_name}/dns-alias', 'us-east-1')
        
        # Parse allowed CIDRs (empty string results in empty list)
        allowed_cidrs = [cidr.strip() for cidr in allow_cidrs_str.split(',') if cidr.strip()]
        
        # Get client IP
        client_ip = get_client_ip(request)
        print(f"Client IP: {client_ip}")
        
        # Check if IP is allowed
        if is_ip_allowed(client_ip, allowed_cidrs):
            print(f"IP {client_ip} is allowed")
            return request
        
        # IP not allowed - either redirect or proxy backup page
        # Check response mode from SSM (default: redirect for backward compatibility)
        response_mode_param = f"/{env}/{function_name}/response-mode"
        response_mode = get_ssm_parameter(response_mode_param, 'us-east-1', default='redirect')
        
        if response_mode == 'proxy':
            # Proxy mode: Fetch and return backup content (keeps URL the same)
            print(f"IP {client_ip} is NOT allowed, proxying content from {dns_alias}")
            
            try:
                import urllib3
                http = urllib3.PoolManager()
                
                # Fetch the backup page - always request /index.html
                alias_response = http.request(
                    'GET', 
                    f'https://{dns_alias}/index.html',
                    headers={'User-Agent': 'CloudFront-IP-Gate-Proxy'},
                    timeout=3.0
                )
                
                # Return the backup content
                response = {
                    'status': str(alias_response.status),
                    'statusDescription': 'OK' if alias_response.status == 200 else 'Service Unavailable',
                    'headers': {
                        'content-type': [{
                            'key': 'Content-Type',
                            'value': alias_response.headers.get('Content-Type', 'text/html')
                        }],
                        'cache-control': [{
                            'key': 'Cache-Control',
                            'value': 'no-cache, no-store, must-revalidate, max-age=0'
                        }],
                        'x-ip-gate-mode': [{
                            'key': 'X-IP-Gate-Mode',
                            'value': 'proxy'
                        }]
                    },
                    'body': alias_response.data.decode('utf-8')
                }
                
                print(f"Successfully proxied backup page (status {alias_response.status})")
                return response
                
            except Exception as proxy_error:
                print(f"Error proxying backup content: {str(proxy_error)}")
                # Fall back to redirect if proxy fails
                print(f"Falling back to redirect mode")
                response_mode = 'redirect'
        
        # Redirect mode (default): HTTP 302 redirect to backup site
        print(f"IP {client_ip} is NOT allowed, redirecting to {dns_alias}")
        
        response = {
            'status': '302',
            'statusDescription': 'Found',
            'headers': {
                'location': [{
                    'key': 'Location',
                    'value': f'https://{dns_alias}'
                }],
                'cache-control': [{
                    'key': 'Cache-Control',
                    'value': 'no-cache, no-store, must-revalidate'
                }],
                'x-ip-gate-mode': [{
                    'key': 'X-IP-Gate-Mode',
                    'value': 'redirect'
                }]
            }
        }
        
        return response
        
    except Exception as e:
        print(f"Error in IP gating function: {str(e)}")
        # On error, allow the request to proceed (fail open)
        # Change this to fail closed if preferred
        return request
